;;;;
.program motorPWM
.side_set 2 opt
    pull noblock side 0b00 ; Pull from FIFO to OSR if available, else copy X to OSR.
    mov x, osr             ; Copy most-recently-pulled value back to scratch X
    mov y, isr             ; ISR contains PWM period. Y used as counter.
countloop:
    jmp x!=y noset         ; Set pin high if X == Y, keep the two paths length matched
    jmp pin setpin1
    jmp skip side 0b10
setpin1:
    jmp skip side 0b01
noset:
    nop                    ; Single dummy cycle to keep the two paths the same length
skip:
    jmp y-- countloop      ; Loop until Y hits 0, then pull a fresh PWM value from FIFO


% c-sdk {
static inline void motorPWM_program_init(PIO pio, uint sm, uint offset, uint firstPWMpin, uint jumpPin) {
    // Initialize the output pins
    pio_gpio_init(pio, firstPWMpin);
    pio_gpio_init(pio, firstPWMpin + 1);
    //pio_gpio_init(pio, jumpPin);
    
    // Set consecutive pin directions for both output pins
    pio_sm_set_consecutive_pindirs(pio, sm, firstPWMpin, 2, true);

    // Load default config and set side-set pins
    pio_sm_config c = motorPWM_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, firstPWMpin);
    
    // Set the pin used for conditional jump
    sm_config_set_jmp_pin(&c, jumpPin);

    // Configure clkdiv, assuming 1 as the value
    sm_config_set_clkdiv(&c, 1);

    // Initialize the state machine with the updated configuration
    pio_sm_init(pio, sm, offset, &c);

    // Set both pins to 0
    pio_sm_set_pins(pio, sm, 0);
}
%}


